#!/bin/sh
#-- NOTE: Default to POSIX shell/mode. Be mindful of your reasons before
#--       switching to Bash, and consider using Python instead...
#-- WARNING: This is a constructed script. Edit the components, not the full file.
#==============================================================================
#:"""
#: .. program:: {{ script_name|default("TODO: CHANGEME", true) }}
#:    :synopsis: {{ script_synopsis|default("TODO: CHANGEME", true) }}
#:
#:    :copyright: {{ software_copyright|default("TODO: CHANGEME", true) }}
#:    :license: {{ software_license|default("TODO: CHANGEME", true) }}
#:
#: .. codeauthor:: {{ full_name|default("TODO: CHANGEME", true) }} <{{ email|default("TODO: CHANGEME", true) }}>
#:
#: .. note:
#:     For guidance, please refer to:
#:
#:         - 'POSIX.1-2008 Base Specification, Issue 7 <http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html>'_
#:         - 'GNU Coding Standard <http://www.gnu.org/prep/standards/>'_
#:
#: .. note:
#:     ShellCheck should be used, accepted issues should be marked w/disable comment
#:
#: .. warning:
#:     Option parsing is currently less-than-ideal
#:
#: {{ script_description|default("TODO: CHANGEME- description for documentation", true) }}
#:"""
#==============================================================================
#: .. section:: Preamble (script-specific vars -- override this)
#: .. revision:: 2019-07-10
#------------------------------------------------------------------------------
#-- Variables which are meta for the script should be dunders (__varname__)
#-- TODO: UPDATE meta vars
__version__='{{ version|default("TODO: CHANGEME", true) }}' #: current version
__revised__='20190710-125741' #: date of most recent revision
__contact__='{{ contact_name|default("TODO: CHANGEME", true) }} <{{ contact_email|default("TODO: CHANGEME", true) }}>' #: primary contact for support/?'s
__synopsis__='{{ script_synopsis|default("TODO: CHANGEME", true) }}'
__description__="
{{ script_description|default('TODO: CHANGEME - description for --help', true) }}
"
#------------------------------------------------------------------------------
#-- TODO: If you want to hard-set some variables, do it here. For example:
# BACKUP_DSF:="+%Y%m%d-%H%M%S"
# DEFAULT_TIMESTAMP="+%Y%m%d-%H%M%S"
# LOGGER_DSF="+%Y%m%d-%H%M%S"
# LOGGER_FILE="${HOME}/var/log/{{ script_name|default("script_logger", true) }}.$(date +%Y%m%d-%H%M%S).log"
# LOGGER_LVL:="info"
#------------------------------------------------------------------------------
#-- Flags
__require_root__='false'    #: Does script require root
__container_safe__='false'  #: Are we safe to run inside a Docker container?
__gnu_version__='false'     #: If true print GNU version string (which includes copyright/license)
__script_debug__='false'    #: This can be set to 'true' via --debug paramater
#==============================================================================
#-- The following few variables should be relatively static over life of script
__author__='{{ full_name|default("TODO: CHANGEME", true) }} <{{ email|default("TODO: CHANGEME", true) }}>' #: coder(s) of script
__created__='{{ date|default("TODO: CHANGEME", true) }}'               #: date script originlly created
__copyright__='{{ software_copyright|default("TODO: CHANGEME", true) }}' #: Copyright short name
__license__='{{ software_license|default("TODO: CHANGEME", true) }}'
__cononical_name__='{{ script_name|default("TODO: CHANGEME", true) }}' #: static name, *NOT* os.path.basename(sys.argv[0])
__project_name__='{{ project_name|default("TODO: CHANGEME", true) }}'  #: name of overall project, if needed
__project_home__='{{ project_home|default("TODO: CHANGEME", true) }}'  #: where to find source/documentation
__template_version__='3.0.0'  #: version of template file used
#==============================================================================
#: .. section:: General variables & settings
#: .. revision:: 2019-07-05
#------------------------------------------------------------------------------
__basename__="${0}"                                    #: name script run as
#-- We are not using this variable for now.
# shellcheck disable=2034
__docformat__='reStructuredText en'                    #: attempted style for documentation
__original_args__="${*}"    #: capture original arg list before messing with it
#------------------------------------------------------------------------------
#-- Load in environment variables, or set defaults
__default_dsf__=${DEFAULT_TIMESTAMP:="+%Y%m%d-%H%M%S"} #: Default format for 'date' command
__logln_dsf__=${LOGGER_DSF:="+%Y%m%d-%H%M%S"}         #: Debug logging output format for 'date' command
__backup_dsf__=${BACKUP_DSF:="+%Y%m%d-%H%M%S"}         #: Backup file format for 'date' command
__logln_file__=${LOGGER_FILE:="nil"}                  #: Path & name of log file to use
case "$(printf '%s' "${LOGGER_LVL:="info"}" | tr '[:upper:]' '[:lower:]')" in
    debug)          __logln_lvl__=10 ;;
    info)           __logln_lvl__=20 ;;
    warn|warning)   __logln_lvl__=30 ;;
    error)          __logln_lvl__=40 ;;
    crit|critical)  __logln_lvl__=50 ;;
    *)              __logln_lvl__=0 ;;
esac
#------------------------------------------------------------------------------
#-- Load colors from environment variables, or set to empty
cf_black=${cf_black:=''}   ; cf_white=${cf_white:=''}
cf_orange=${cf_orange:=''} ; cf_magenta=${cf_magenta:=''}
cf_yellow=${cf_yellow:=''} ; cf_red=${cf_red:=''}
cf_purple=${cf_purple:=''} ; cf_blue=${cf_blue:=''}
cf_cyan=${cf_cyan:=''}     ; cf_green=${cf_green:=''}
c_bold=${c_bold:=''}       ; c_reset=${c_reset:=''}
c_undr=${c_undr:=''}       ; c_hide=${c_hide:=''}
c_blik=${c_blik:=''}       ; c_revr=${c_revr:=''}
#------------------------------------------------------------------------------
#-- Set some default settings
#-- NOTE: If you don't want to handle these error conditions yourself,
#         then uncomment these.
# set -o errexit  # Exit if any statement returns non-true value
# set -o nounset  # Exit if attempt to use an uninitialised variable
#------------------------------------------------------------------------------
#-- Check for debug & full debug flags
#   NOTE: this is not POSIX
if [ "${*#*--debug}" != "${*}" ]; then
    #-- Only do full shell trace if external DEBUG var set to full
    [ "${DEBUG}" = 'full' ] && set -o xtrace
fi
#------------------------------------------------------------------------------
#-- Basic environment setup
#   Ref: https://github.com/fedora-sysv/initscripts)
#------------------------------------------------------------------------------
#-- Sane umask
umask 022
#-- Sane command search path
PATH="/sbin:/usr/sbin:/bin:/usr/bin"
#-- Sane screen width
[ -z "${COLUMNS:-}" ] && COLUMNS=80
if [ -z "${CONSOLETYPE:-}" ]; then
    if [ -c "/dev/stderr" ] && [ -r "/dev/stderr" ]; then
        if [ -x "$(command -v consoletype)" ] ; then
            CONSOLETYPE="$(consoletype < /dev/stderr 2>/dev/null)"
        elif [ -x "$(command -v tty)" ] ; then
            CONSOLETYPE="$(tty 2>/dev/null | cut -d'/' -f3)"
        else
            CONSOLETYPE='unknown'
        fi
    else
        CONSOLETYPE='serial'
    fi
fi
#==============================================================================
_debug_info() {
    #:"""
    #: .. function:: _debug_info()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-05
    #:
    #: Provides meta info for debug-level output
    #:
    #: .. note::
    #:     We set script_path here to avoid calling cd/dirname/pwd when not really needed
    #:"""
    # shellcheck disable=SC1007
    script_path="$(CDPATH= cd -- "$(dirname -- "${0}")" && pwd )"

    logln debug "Cononical: ${__cononical_name__}"
    logln debug "Abs Path:  ${script_path}/${__basename__}"
    logln debug "Args List: ${__original_args__}"
    logln debug "Version:   ${__version__}"
    logln debug "md5sum:    $(md5sum "${__basename__}" 2>&1)"
    logln debug "Created:   ${__created__}"
    logln debug "Revised:   ${__revised__}"
    logln debug "Coder(s):  ${__author__}"
    logln debug "Contact:   ${__contact__}"
    logln debug "Project:   ${__project_name__}"
    logln debug "Project Home: ${__project_home__}"
    logln debug "Template Version: ${__template_version__}"
    logln debug "System:    $(uname -orv 2>&1)"
    logln debug "Hostname:  $(hostname 2>&1)"
    logln debug "Logname:   ${USERNAME:=$(logname 2>&1)}"
    logln debug "[re]uid:   $(id -ur 2>&1)/$(id -u 2>&1)"
    logln debug "PID/PPID:  ${$}/${PPID}"
    if [ -x /bin/pstree ] || [ -x /usr/bin/pstree ] ; then
        if pstree -psu ${$} 1>/dev/null 2>&1 ; then
            logln debug "pstree psu: $(pstree -psu ${$})"
        else
            logln debug "pstree pu: $(pstree -pu ${$})"
        fi
    fi
    logln debug '-----------------'
    logln debug '----- start -----'
    logln debug '-----------------'

    return
}
#==============================================================================
_usage() {
    #:"""
    #: .. function:: _usage()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: Provides usage information
    #:
    #: .. note::
    #:     GNU does not recommend short options for help/version.
    #:     I do not recommend short option for, nor display of, debug option.
    #:     but I do recommend short option for help.
    #:"""
    printf 'Usage: %s [options]\n\n' "${__basename__}"
    printf '%s\n\n' "${__synopsis__}"
    printf 'Options:\n'
    usage_options '  %s     %s\n'
    printf '\n%s\n\n' "${__description__}"
    printf 'Created: %s  Contact: %s\n' "${__created__}" "${__contact__}"
    printf 'Revised: %s  Version: %s\n' "${__revised__}" "${__version__}"
    printf '(c) Copyright %s (License: %s)\n'   "${__copyright__}" "${__license__}"
    printf '%s, part of %s. Project home: %s\n' "${__cononical_name__}" \
                                                "${__project_name__}" \
                                                "${__project_home__}"

    return
}
#==============================================================================
_usage_ec() {
    #:"""
    #: .. function:: _usage_ec()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: Print reStructuredText-compatible table of exit conditions
    #:"""
    # NOTE: This is not yet POSIX-safe
    __usage_ec_lst=$(grep exit_error "${__basename__}" \
                    | sed 's/.*exit_error //g' \
                    | grep '^[0-9]' \
                    | sed 's/.[0-9-][0-9-]\.[0-9][0-9]//g' \
                    | sed 's/ *;;//g' \
                    | tr -d '"' | tr -d "'" \
                    | sort -u | sort -n) # \
        #| awk '{printf "| " $1 " | "; for (i=2; i<NF; i++) printf $i " "; print $NF " |"}'
    while read -r __usage_ec_line ; do
        __usage_ec_num="$(printf '%s' "${__usage_ec_line}" | cut -d' ' -f1)"
        __usage_ec_des="$(printf '%s' "${__usage_ec_line}" | cut -d' ' -f2- | cut -c -67)"
        printf '| %3d | %-67s |\n' "${__usage_ec_num}" "${__usage_ec_des}"
    done <<< "${__usage_ec_lst}"

    return
}
#==============================================================================
_usage_rest() {
    #:"""
    #: .. function:: _usage_rest()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: Provides usage information in Sphinx/ReST format.
    #:
    #:"""
    # {% raw %}
    __usage_rest_char="%${#__cononical_name__}s" # {% endraw %}
    #-- We are using a variable to format data in printf
    # shellcheck disable=2059
    printf "${__usage_rest_char}\\n" | tr " " "="
    printf '%s\n' "${__cononical_name__}"
    #-- We are using a variable to format data in printf
    # shellcheck disable=2059
    printf "${__usage_rest_char}\\n" | tr " " "="
    printf '\n'
    printf 'Synopsis\n'
    printf '%s\n\n' '--------' "${__synopsis__}"
    printf '**%s** [*options*]\n\n' "${__cononical_name__}" #: TODO: UPDATE usage
    printf 'Description\n'
    printf '%s\n\n' '-----------'
    printf '%s\n\n' "${__description__}"
    printf 'Options\n'
    printf '%s\n\n' '-------'
    usage_options '.. option:: %s\n\n    %s\n\n'
    printf 'Author\n'
    printf '%s\n\n' '------'
    printf '%s\n\n' "${__author__}"
    printf 'Copyright\n'
    printf '%s\n\n' '------'
    printf '(c) Copyright %s (License: %s)\n\n' "${__copyright__}" "${__license__}"

    return
}
#==============================================================================
_version() {
    #:"""
    #: .. function:: _version()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: Provides version information
    #:
    #: .. note::
    #:     GNU guidelines dictate adding copyright and license info
    #:"""
    printf '%s (%s) %s\n' "${__cononical_name__}" "${__project_name__}" "${__version__}"
    if [ "${__gnu_version__}" = 'True' ]; then
        printf 'Copyright %s\n' "${__copyright__}"
        printf 'License %s\n' "${__license__}"
    fi

    return
}
#==============================================================================
exit_clean() {
    #:"""
    #: .. function:: exit_clean()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-05
    #:
    #: Clean up everything and exit gracefully
    #: .. warning::
    #:     This function exits the script
    #:"""
    [ "${__script_debug__}" = true ] && {
        set +o xtrace
        logln debug '-----------------'
        logln debug '------ end ------'
        logln debug '-----------------'
        __script_debug__=false
    }

    trap - INT TERM HUP
    if [ "${__logln_file_set__}" = "true" ]; then
        printf '%s [EXIT]: Script finished.\n' "$(get_timestamp "${__logln_dsf__}")" 1>&3
        printf 'Log file created: %s\n' "${__logln_file__}"
        exec 3>&-
    fi
    exit 0

    return
}
#==============================================================================
_exit_trap() {
    #:"""
    #: .. function:: exit_error()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: On terminal traps, run this before exit_error
    #:
    #: :param int trap_line: Line number trap caught on
    #: :param str trap_name: Short name of trap
    #: .. warning::
    #:     This function calls exit_error, which exits the script
    #:"""
    exit_error "${?}" "caught trap ${2} at line ${1}; exiting"
}
#:"""
#: .. note::
#:     Setting traps seprately for 2 reasons:
#:
#:         - Avoid calling "$(kill -l $((trap_num - 128)))" in exti_trap
#:         - Incase we want to handle them differently in the future
#:
#: .. describe:: Bug
#:     Passing LINENO may not be working as expected, need more real-world tests
#:"""
trap '_exit_trap ${LINENO} INT'  INT
trap '_exit_trap ${LINENO} TERM' TERM
trap '_exit_trap ${LINENO} HUP'  HUP
#==============================================================================
exit_error() {
    #:"""
    #: .. function:: exit_error()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-05
    #:
    #: Report error and exit
    #:
    #: :param int error_number:  Number to use for Exit Code
    #: :param str error_string:  Short description of error
    #: .. note::
    #:     You may want to use ${LINENO} in the string this is called with.
    #: .. warning::
    #:     This function exits the script
    #:"""
    if [ "${#}" -eq 2 ] ; then # {% endraw %}
        __exit_error_code="${1}"
        __exit_error_mess="${2}"
    else
        __exit_error_code=128
        __exit_error_mess='Invalid arguments for exit_error()'
    fi

    trap - INT TERM HUP
    printf '%s: %s\n' "${cf_red}${__cononical_name__}" \
                      "${c_bold}${__exit_error_mess}${c_reset}" 1>&2
    if [ "${__logln_file_set__}" = "true" ]; then
        printf '%s [EXIT]: %s\n' "$(get_timestamp "${__logln_dsf__}")" "${__exit_error_mess}" 1>&3
        printf 'Log file created: %s\n' "${__logln_file__}"
        exec 3>&-
    fi
    exit "${__exit_error_code}"
}
#==============================================================================
get_timestamp() {
    #:"""
    #: .. function:: get_timestamp()
    #:
    #: Return a timestamp in a defined format.
    #:
    #: :param str array: Any params accepted by the date(1) command.
    #: :return: The date string. Ideally without whitespace.
    #: :rtype: str
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 20190705-1050
    #:"""# {% raw %}
    if [ "${#}" -eq 0 ]; then # {% endraw %}
        date "${__default_dsf__}" || return "${?}"
    else
        date "${@}" || return "${?}"
    fi

    return
}
#==============================================================================
is_false() {
    #:"""
    #: .. function:: is_false()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: Check if a string is a standard false flag
    #: Ref: https://github.com/fedora-sysv/initscripts)
    #:
    #: :param str boolean:   String to check
    #:"""# {% raw %}
    if [ "${#}" -ne 1 ] ; then # {% endraw %}
        return 64
    fi
    case "${1}" in
        [fF] | [nN] | [nN][oO] | [fF][aA][lL][sS][eE] | 0) return 0 ;;
        *) return 1
    esac
}
#==============================================================================
is_in_string() {
    #:"""
    #: .. function:: is_in_string()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: Check if a substring is in a string
    #:
    #: :param str needle:   Substring to search for
    #: :param str heystack: String to search in
    #:"""
    case "${2}" in
        *${1}*) return 0 ;;
        *)      return 1 ;;
    esac ;
}
#==============================================================================
is_true() {
    #:"""
    #: .. function:: is_true()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-06-28
    #:
    #: Check if a string is a standard true flag
    #: Ref: https://github.com/fedora-sysv/initscripts)
    #:
    #: :param str boolean:   String to check
    #:"""# {% raw %}
    if [ "${#}" -ne 1 ] ; then # {% endraw %}
        return 64
    fi
    case "${1}" in
        [tT] | [yY] | [yY][eE][sS] | [tT][rR][uU][eE] | 1) return 0 ;;
        *) return 1
    esac
}
#==============================================================================
mk_tmp() {
    #:"""
    #: .. function:: mk_tmp()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-05
    #:
    #: Creates a temporary file (or directory), returning the path. Defaults to file.
    #:
    #: :param str directory:   Pass any substring of 'directory' to create a directory
    #:
    #:"""
    __mk_tmp_dir='' # {% raw %}
    if [ "${#}" -eq 1 ] ; then # {% endraw %}
        case 'directory' in
            *${1}*) __mk_tmp_dir='-d' ;;
            *)      ;;
        esac ;
    fi
    if command -v mktemp >/dev/null 2>&1; then
        mktemp ${__mk_tmp_dir} -t "${__cononical_name__}${__mk_tmp_dir}.XXXXXXXXXX" || return "${?}"
    else
        if [ "${__mk_tmp_dir}" = '' ]; then
            __mk_tmp_path="/tmp/${__cononical_name__}.${$}"
            touch "${__mk_tmp_path}" || return "${?}"
        else
            __mk_tmp_path="/tmp/${__cononical_name__}-d.${$}"
            mkdir "${__mk_tmp_path}" || return "${?}"
        fi
        printf '%s' "${__mk_tmp_path}"
    fi

    return
}
#==============================================================================
set_value_in_file() {
    #:"""
    #: .. function:: set_value_in_file()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-05
    #:
    #: Add or change a KEY to a VALUE in a FILE, creating FILE if necessary.
    #:
    #: :param str file:   FILE to create/modify
    #: :param str key:    KEY to create/modify
    #: :param str value:  VALUE to set key to
    #: :param str quote:  set to 'noquote' if VALUE should not be quoted
    #:"""# {% raw %}
    if [ "${#}" -ne 3 ] && [ "${#}" -ne 4 ] ; then # {% endraw %}
        return 64
    fi
    __set_value_in_file_file="${1}"
    __set_value_in_file_key="${2}"
    __set_value_in_file_value="${3}"
    if ! [ "${4}" = 'noquote' ] ; then
        __set_value_in_file_value="'${__set_value_in_file_value}'"
    fi
    if sed -h 2>&1 | grep -q '\-E' ; then
        __set_value_in_file_sedopt='-E'
    else
        __set_value_in_file_sedopt='-r'
    fi

    if [ ! -e "${__set_value_in_file_file}" ] ; then
        touch "${__set_value_in_file_file}" || return "${?}"
    fi
    if grep -q "^${__set_value_in_file_key}=" "${__set_value_in_file_file}" ; then
        sed -i ${__set_value_in_file_sedopt} \
            "s|^${__set_value_in_file_key} *=.*|${__set_value_in_file_key}=${__set_value_in_file_value}|" \
            "${__set_value_in_file_file}" || return "${?}"
    else
        printf '%s=%s\n' "${__set_value_in_file_key}" "${__set_value_in_file_value}" \
            >> "${__set_value_in_file_file}" || return "${?}"
    fi

    return
}
#==============================================================================
logln() {
    #:"""
    #: .. function:: logln()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-05
    #:
    #: Provides an interface similar to Python's logging module
    #:
    #: :param str log_level:     String indicating log level
    #: :param str log_string:    String to print
    #: .. note::
    #:     This was inspired by tinylogln (Copyright (c) 2017 Nagarjuna
    #:     Kumarappan), but I think there is very little left of the original
    #:     code here. See: https://github.com/nk412/tinylogln
    #:"""
    case "$(printf '%s' "${1}")" in
        debug)          __logln_action_tag='DEBUG'    ; __logln_log_level_th=10 ;;
        info)           __logln_action_tag='INFO'     ; __logln_log_level_th=20 ;;
        warn|warning)   __logln_action_tag='WARNING'  ; __logln_log_level_th=30 ;;
        error)          __logln_action_tag='ERROR'    ; __logln_log_level_th=40 ;;
        crit|critical)  __logln_action_tag='CRITICAL' ; __logln_log_level_th=50 ;;
        *)              __logln_action_tag='UNKNOWN'  ; __logln_log_level_th=0 ;;
    esac
    shift

    if [ "${__logln_file_set__}" = "true" ]; then
        printf '%s [%s]: %s\n' "$(get_timestamp "${__logln_dsf__}")" \
                               "${__logln_action_tag}" "${@}" 1>&3
    fi

    if [ "${__logln_lvl__}" -le "${__logln_log_level_th}" ]; then
        if [ "${__script_debug__}" = true ]; then
            printf '%s %-10s ' "${cf_blue}$(get_timestamp "${__logln_dsf__}")" \
                               "${__logln_action_tag}${c_reset}"
        fi
        if [ "${__logln_log_level_th}" -le 10 ]; then
            printf '%sdebug: %s%s\n' "${cf_green}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 20 ]; then
            printf '%s%s%s\n' "${cf_white}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 30 ]; then
            printf '%sWarning: %s%s\n' "${cf_yellow}" "${@}" "${c_reset}" 1>&2
        elif [ "${__logln_log_level_th}" -le 40 ]; then
            printf '%sError: %s%s\n' "${cf_magenta}" "${@}" "${c_reset}" 1>&2
        else
            printf '%sCRITICAL: %s%s\n' "${cf_red}" "${@}" "${c_reset}" 1>&2
        fi
    fi

    return
}
#==============================================================================
init() {
    #:"""
    #: .. function:: init()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-05
    #:
    #: Check for requirements, other set-up stuff
    #:"""
    #--------------------------------------------------------------------------
    #-- Check if effectively root
    #--------------------------------------------------------------------------
    if is_true "${__require_root__}" && [ "$(id -u)" -ne 0 ] ; then
      exit_error 77 'Must be run as root.'
    fi
    #--------------------------------------------------------------------------
    #-- Check if running inside Docker container
    #--------------------------------------------------------------------------
    if is_false "${__container_safe__}" && grep -q '/docker' /proc/self/cgroup ; then
      exit_error 78 'This script is not container safe.'
    fi
    #--------------------------------------------------------------------------
    #-- Set up log file
    if [ "${__logln_file__}" != "nil" ]; then
        mkdir -p "$(dirname "${__logln_file__}")"
        if [ -f "${__logln_file__}" ] ; then
            mv "${__logln_file__}" "${__logln_file__}"."$(get_timestamp "${__backup_dsf__}")"
        fi
        exec 3<> "${__logln_file__}" || exit 1
        __logln_file_set__='true'
    else
        exec 3>&1 || exit 1
        __logln_file_set__='false'
    fi
    _debug_info
    #--------------------------------------------------------------------------
    return
}
#==============================================================================
usage_options() {
    #:"""
    #: .. function:: usage_options()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-10
    #:
    #: :param str option_strfmt: The format to use.
    #:"""
    #-- TODO: UPDATE option list.# {% raw %}
    if [ "${#}" -eq 1 ] ; then
        __usage_option_strfmt="${1}"
    elif [ "${#}" -eq 0 ] ; then # {% endraw %}
        __usage_option_strfmt='%s (%s)\n'
    else
        return 64
    fi

    #-- We are using a variable to format data in printf
    # shellcheck disable=2059
    printf "${__usage_option_strfmt}" '--help, -h' 'Dislay this help'
    #-- We are using a variable to format data in printf
    # shellcheck disable=2059
    printf "${__usage_option_strfmt}" '--version ' 'Display version'

    return
}
#==============================================================================
parse_options() {
    #:"""
    #: .. function:: parse_options()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-10
    #:
    #: :param: This function should be passed the scripts $@.
    #:
    #: NOTE: this is not optimal, but is an attempt to keep things POSIX
    #:       compliant. If you are expecting arguments instead of params,
    #:       be sure to assign them... somehow...
    #: Be sure to update usage_options() as well
    #:"""
    # {% raw %}
    while [ "${#}" -gt 0 ]; do  # {% endraw %}
        case "${1}" in
            --debug)     __script_debug__='true'
                         __logln_lvl__=10
                         shift ;;
            -h|--help)   _usage      && exit 0 ;;
            --help-ec)   _usage_ec   && exit 0 ;;
            --help-rest) _usage_rest && exit 0 ;;
            --version)   _version    && exit 0 ;;
            # -e|--exam)   EXAMPLE="${2}" && shift 2 ;;
            # -f|--flage)  FLAG="true" && shift ;;
            # --)          shift && break ;;
            # -?*)         exit_error 64 "Invalid option: ${1}" ;;
            *)           exit_error 64 "Invalid option: ${1}" ;;
        esac
    done
}
#==============================================================================
#: .. section:: Body -- This is where The Magic(TM) happens
#: .. revision:: 2019-07-10
main() {
    #-- TODO: Do something more interesting here...{#
    logln debug "this is a debug"
    logln info  "this is an info"
    logln warn  "this is a warning"
    logln error "this is an error"
    logln crit  "this is critical"
    #}

}
#==============================================================================
if [ "$(type -t parse_options 2>/dev/null)" = 'function' ] ; then
    parse_options "${@}"
fi
init
main
exit_clean
