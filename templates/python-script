#!/usr/bin/python2 -tt
# -*- coding: utf-8 -*-
# ^^-- use utf-8 strings by default
#-- NOTE: Tabs and spaces do NOT mix!! '-tt' will flag violations as an error.{#
# pylint: disable=line-too-long
#-- line-too-long is inevitable with the Jinga2 strings #}
#===============================================================================
#-- Preamble v2.0.0
#===============================================================================
'''{#
    .. py:module:: python_script
    #}
    :program:`{{ script_name|default("TODO: CHANGEME", true) }}`
    ============================================================

    In addition to the options listed in help output, :program:`{{ script_name|default("TODO: CHANGEME", true) }}` includes
    the following 'hidden' options:

    .. option:: --help-rest

        Output usage information in Sphinx/reST-style markup.

    .. option:: --debug

        Output debug-level information.

    :synopsis: {{ script_synopsis|default("TODO: CHANGEME", true) }}

    :copyright: {{ software_copyright|default("TODO: CHANGEME", true) }}
    :license: {{ software_license|default("TODO: CHANGEME", true) }}

    .. codeauthor:: {{ full_name|default("TODO: CHANGEME", true) }} <{{ email|default("TODO: CHANGEME", true) }}>
'''
#===============================================================================
#-- Standard Imports
#-- NOTE: See __future__ documentation at https://docs.python.org/2/library/__future__.html
#--       This allows us to write Python 3 code for older version.
from __future__ import absolute_import  #: Require parens to group imports PEP-0328
from __future__ import division         #: Enable 3.x True Division PEP-0238
from __future__ import with_statement   #: Clean up some uses of try/except PEP--343
#-- These may break 2.5 compatibility
from __future__ import print_function   #: Makes print a function, not a statement PEP-3105
from __future__ import unicode_literals #: Introduce bytes type for older strings PEP-3112
try:
    import ConfigParser #: 'Easy' configuration parsing
except ImportError:
    import configparser as ConfigParser#: At some point this was required...
#-- NOTE: We use optparse for compatibility with python < 2.7 as
#--       argparse wasn't standard until 2.7 (2.7 deprecates optparse)
#--       As of 20161212 the template is coded for optparse only
import optparse     #: pylint: disable=deprecated-module
import logging      #: Python's standard logging facilities
import os           #: Misc. OS interfaces
import sys          #: System-specific parameters & functions
# import traceback    #: Print/retrieve a stack traceback
#==============================================================================
#-- Third Party Imports
#==============================================================================
#-- Require a minimum Python version
if sys.version_info <= (2, 6):
    sys.exit("Minimum Python version: 2.6")
#-- NOTE: default Python versions:
#--       RHEL4    2.3.4
#--       RHEL5    2.4.3
#--       RHEL6.0  2.6.5
#--       RHEL6.1+ 2.6.6
#--       RHEL7    2.7.5
#--       RHEL8    3.6.7 *(not confirmed)
#-- Recent Fedora versions (24/25) stay current on 2.7 (2.7.12 as of 20161212)
#==============================================================================
#==============================================================================
#-- Application Library Imports
#==============================================================================
#-- Variables which are meta for the script should be dunders (__varname__)
#-- TODO: Update meta vars
__version__ = '{{ version|default("TODO: CHANGEME", true) }}' #: current version
__revised__ = '20191211-154644' #: date of most recent revision
__contact__ = '{{ contact_name|default("TODO: CHANGEME", true) }} <{{ contact_email|default("TODO: CHANGEME", true) }}>' #: primary contact for support/?'s
__synopsis__ = '{{ script_synopsis|default("TODO: CHANGEME", true) }}'
__description__ = '''{{ script_description|default("TODO: CHANGEME", true) }}
'''
#------------------------------------------------------------------------------
#-- The following few variables should be relatively static over life of script
__author__ = ['{{ full_name|default("TODO: CHANGEME", true) }} <{{ email|default("TODO: CHANGEME", true) }}>'] #: coder(s) of script
__created__ = '{{ date|default("TODO: CHANGEME", true) }}'               #: date script originlly created
__copyright__ = '{{ software_copyright|default("TODO: CHANGEME", true) }}' #: Copyright short name
__license__ = '{{ software_license|default("TODO: CHANGEME", true) }}'
__cononical_name__ = '{{ script_name|default("TODO: CHANGEME", true) }}' #: static name, *NOT* os.path.basename(sys.argv[0])
__project_name__ = '{{ project_name|default("TODO: CHANGEME", true) }}'  #: name of overall project, if needed
__project_home__ = '{{ project_home|default("TODO: CHANGEME", true) }}'  #: where to find source/documentation
__template_version__ = '3.0.0'  #: version of template file used
#-- We are not using this variable for now.
__docformat__ = 'reStructuredText en'       #: attempted style for documentation
__basename__ = os.path.basename(sys.argv[0]) #: name script run as
#------------------------------------------------------------------------------
#-- Flags
__gnu_version__ = False #: If True print GNU version string (which includes copyright/license)
__require_root__ = False    #: Does script require root
#------------------------------------------------------------------------------
#-- Load in environment variables, or set defaults
__default_dsf__ = os.getenv('DEFAULT_TIMESTAMP') if 'DEFAULT_TIMESTAMP' in os.environ else "%Y%m%d-%H%M%S"
__logger_dsf__ = os.getenv('LOGGER_DSF') if 'LOGGER_DSF' in os.environ else __default_dsf__
__backup_dsf__ = os.getenv('BACKUP_DSF') if 'BACKUP_DSF' in os.environ else __default_dsf__
__logger_file__ = os.getenv('LOGGER_FILE') if 'LOGGER_FILE' in os.environ else None
__logger_lvl__ = os.getenv('LOGGER_LVL') if 'LOGGER_LVL' in os.environ else 'info'

EXIT_STATUS = None
#------------------------------------------------------------------------------
METAVARS = {
    'name': __cononical_name__,
    'basename': __basename__,
    'script': {
        'version': __version__,
        'revised': __revised__,
        'contact': __contact__,
        'synopsis': __synopsis__,
        'description': __description__,
        'author': __author__,
        'created': __created__,
        'copyright': __copyright__,
        'license': __license__,
        'cononical_name': __cononical_name__,
        'project_name': __project_name__,
        'project_home': __project_home__,
        'template_version': __template_version__,
        'docformat': __docformat__,
        'basename': __basename__
    },
    'flags': {
        'gnu_version': __gnu_version__,
        'require_root': __require_root__
    },
    'env': {
        'default_dsf': __default_dsf__,
        'logger_dsf': __logger_dsf__,
        'backup_dsf': __backup_dsf__,
        'logger_file': __logger_file__,
        'logger_lvl': __logger_lvl__
    }
}

#==============================================================================
#-- Initilize v2.0.0
#==============================================================================
try:
    import ConfigParser #: 'Easy' configuration parsing
except ImportError:
    import configparser as ConfigParser#: At some point this was required...
#-- NOTE: We use optparse for compatibility with python < 2.7 as
#--       argparse wasn't standard until 2.7 (2.7 deprecates optparse)
#--       As of 20161212 the template is coded for optparse only
import optparse #: pylint: disable=deprecated-module
#==============================================================================
class _ModOptionParser(optparse.OptionParser):
    ''' By default format_epilog() strips newlines, we don't want that,
        so we override.
    '''

    def format_epilog(self, formatter):
        ''' We'll preformat the epilog in the decleration, just pass it through '''
        return self.epilog


#==============================================================================
class _ReSTHelpFormatter(optparse.HelpFormatter):
    ''' Format help for Sphinx/ReST output.

    NOTE: All over-ridden methods started life as copy'n'paste from original's
          source code.

    '''

    def __init__(self, name=None):
        optparse.HelpFormatter.__init__(self, indent_increment=0, max_help_position=4,
                                        width=80, short_first=0
                                       )
        self.name = name

    def format_usage(self, usage):
        retval = ['%s\n' % ('=-'[self.level] * len(self.name))]
        retval.append('%s\n' % (self.name))
        retval.append('%s\n\n' % ('=-'[self.level] * len(self.name)))
        retval.append('%s' % self.format_heading('Synopsis'))
        retval.append('**%s** %s\n\n' % (self.name, usage))
        return ''.join(retval)

    def format_heading(self, heading):
        return '%s\n%s\n\n' % (heading, '--'[self.level] * len(heading))

    def format_description(self, description):
        if description:
            retval = ['%s' % self.format_heading('Description')]
            retval.append('%s\n' % self._format_text(description))
            return ''.join(retval)
        return ''

    def format_option(self, option):
        opts = self.option_strings[option]
        retval = ['.. option:: %s\n\n' % opts]
        if option.help:
            # help_text = self.expand_default(option)
            # help_lines = textwrap.wrap(help_text, self.help_width)
            retval.append('%4s%s\n\n' % ('', self.expand_default(option)))
            # retval.extend(['%4s%s\n' % ('', line)
            #                for line in help_lines[1:]])
        elif opts[-1] != '\n':
            retval.append('\n')
        return ''.join(retval)

    def format_option_strings(self, option):
        ''' Return a comma-separated list of option strings & metavariables. '''
        if option.takes_value():
            metavar = option.metavar or option.dest.upper()
            short_opts = ['%s <%s>' % (sopt, metavar)
                          for sopt in option._short_opts] #: pylint: disable=protected-access
                                                          #: We're over-riding the default
                                                          #:    method, keeping most the code.
                                                          #:    Not sure how else we'd do this.
            long_opts = ['%s=<%s>' % (lopt, metavar)
                         for lopt in option._long_opts]   #: pylint: disable=protected-access
        else:
            short_opts = option._short_opts               #: pylint: disable=protected-access
            long_opts = option._long_opts                 #: pylint: disable=protected-access

        if self.short_first:
            opts = short_opts + long_opts
        else:
            opts = long_opts + short_opts

        return ', '.join(opts)


#==============================================================================
class Initilize(object): #: pylint: disable=useless-object-inheritance
    ''' Parse the configuration and options; set up logging

        Returns:
            An object containing settings.

    '''
    __version = '2.0.0'

    _defaults = {
        'debug': False
    }

    _arguments = None
    _configs = None
    _options = None
    _logger_file_set = False

    @property
    def args(self):
        ''' Class property '''
        if self._arguments is not None:
            return self._arguments
        return None

    @property
    def debug(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.debug
        return self._defaults['debug']

    @property
    def ansible_called(self):
        ''' Class property '''
        return bool(self.mvars['basename'].startswith('ansible_module'))

    def __init__(self, args=None, mvars=None):
        if mvars is None:
            raise ValueError('A metavars dict is required!')
        self.mvars = mvars
        self.logger = logging.getLogger(mvars['name'])
        self.logger.setLevel(logging.DEBUG)
        if self._configs is not None:
            raise ValueError('Configs already initialized.')
        self._configs = self._load_configs(mvars['name'])
        if self._options is not None:
            raise ValueError('Arguments already initialized.')
        (self._options, self._arguments) = self._parse_args(args, mvars['script'])
        self._init_logger(mvars['env'])
        if self.debug or self._logger_file_set:
            self._debug_info(mvars['script'])
        self.logger.debug('Initialized Initilize version %s.', self.__version)

    def _load_configs(self, name):
        parser = ConfigParser.SafeConfigParser(defaults=self._defaults)
        parser.read([os.path.expanduser('~/.%s' % name),
                     '%s.cfg' % name])
        #-- TODO: Define possible sections
        if not parser.has_section('debug'):
            parser.add_section('debug')
        return parser

    def _parse_args(self, args, script):
        #-- Parse Options (rely on OptionsParser's exception handling)
        description_string = script['synopsis']
        epilog_string = ('\n%s\n\n'
                         'Created: %s  Contact: %s\n'
                         'Revised: %s  Version: %s\n'
                         '%s, part of %s. Project home: %s\n'
                        ) % (script['description'], script['created'],
                             script['contact'], script['revised'],
                             script['version'], script['cononical_name'],
                             script['project_name'], script['project_home']
                            )
        usage_string = '%s [options]' % (script['basename'])
        version_string = '%s (%s) %s' % (script['cononical_name'],
                                         script['project_name'], script['version'])
        if self.mvars['flags']['gnu_version']:
            version_string += '\nCopyright %s\nLicense %s\n' % (script['copyright'],
                                                                script['license'])
        parser = _ModOptionParser(version=version_string, usage=usage_string,
                                  description=description_string, epilog=epilog_string)
        #-- TODO: Add options, also set _default and @property (if needed).
        #-- Visible Options
        #   These can *not* be set in a config file
        #   These could be set in a config file

        #-- Hidden Options
        #   These can *not* be set in a config file
        parser.add_option('--help-rest', dest='helprest', action='store_true',
                          help=optparse.SUPPRESS_HELP, default=None)
        #   These could be set in a config file
        parser.add_option('--debug', dest='debug', action='store_true',
                          help=optparse.SUPPRESS_HELP,
                          default=self._configs.get('debug', 'debug'))

        parsed_opts, parsed_args = parser.parse_args(args)
        if parsed_opts.helprest:
            parser.formatter = _ReSTHelpFormatter(name=script['cononical_name'])
            parser.usage = '[*options*]'         #: pylint: disable=attribute-defined-outside-init
                                                 #: Not yet sure of a better way to do this...
            parser.description = script['description'] #: pylint: disable=attribute-defined-outside-init
            parser.epilog = '\nAuthor\n------\n\n%s\n' % ('; '.join(script['author']))
            parser.print_help()
            sys.exit(os.EX_OK)
        #-- Put any option validation here...

        return parsed_opts, parsed_args

    def _init_logger(self, env):
        ''' Initilze logger '''
        if self.debug:
            level = logging.DEBUG
            formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s',
                                          env['logger_dsf']
                                         )
        else:
            if env['logger_lvl'].isdigit():
                if int(env['logger_lvl']) > 49:
                    level = logging.CRITICAL
                elif int(env['logger_lvl']) < 10:
                    level = logging.NOTSET
                else:
                    level = (int(env['logger_lvl'])) //10 * 10
            else:
                level = logging.getLevelName(env['logger_lvl'].upper())
            #-- Yes, we are going to ignore unknown values by setting to INFO
            if isinstance(level, str) and level.startswith('Level'):
                level = logging.INFO
            formatter = logging.Formatter('%(message)s')

        #-- Console output
        console = logging.StreamHandler()
        console.setLevel(level)
        console.setFormatter(formatter)
        self.logger.addHandler(console)

        #-- File output
        if env['logger_file']:
            import time
            if os.path.isfile(env['logger_file']):
                os.rename(env['logger_file'], '%s.%s' % (env['logger_file'],
                                                         time.strftime(env['backup_dsf']).strip('+')))
            #: NOTE: In Python >= 2.6 normally I give FileHandler 'delay="true"'
            logfile = logging.FileHandler(env['logger_file'])
            logfile.setLevel(logging.DEBUG)
            formatter = logging.Formatter(
                '%(asctime)s.%(msecs)d:%(levelno)s:%(name)s.%(funcName)s:%(lineno)d:%(message)s',
                env['logger_dsf']
                )
            logfile.setFormatter(formatter)
            self.logger.addHandler(logfile)
            self._logger_file_set = True

    def _debug_info(self, script):
        import platform #: Easily get platforms identifying info
        self.logger.debug('Version:   %s (%s) %s', script['cononical_name'],
                          script['project_name'], script['version'])
        self.logger.debug('Created:   %s / Revised: %s', script['created'], script['revised'])
        self.logger.debug('Abs Path:  %s', os.path.abspath(sys.argv[0]))
        self.logger.debug('Full Args: %s', ' '.join(sys.argv[:]))
        self.logger.debug('Python:    %s (%s)', sys.executable, platform.python_version())
        self.logger.debug('Coder(s):  %s', script['author'])
        self.logger.debug('Contact:   %s', script['contact'])
        self.logger.debug('Project Home: %s', ['project_home'])
        self.logger.debug('Template Version: %s', script['template_version'])
        self.logger.debug('System:    %s', platform.system_alias(platform.system(),
                                                                 platform.release(),
                                                                 platform.version()
                                                                )
                         )
        self.logger.debug('Platform:  %s', platform.platform())
        self.logger.debug('Hostname:  %s', platform.node())
        self.logger.debug('Logname:   %s', os.getlogin())
        self.logger.debug('[re]uid:  %s/%s', os.getuid(), os.geteuid())
        self.logger.debug('PID/PPID:  %s/%s', os.getpid(), os.getppid())
        if self._options is not None:             #: pylint: disable=protected-access
            self.logger.debug('Parsed Options: %s', self._options) #: pylint: disable=protected-access
        if self.debug:
            print('\n----- start -----\n')


#==============================================================================
#-- MiscFunctions v2.0.0
#==============================================================================
def get_temp(directory=None, stem=None):
    ''' Creates a temporary file (or directory), returning the path.
        Defaults to file.

    Args:
        program (str): Name of program to find.

    Returns:
        For directory: absolute path to directory as a string.
        For a file: a tuple with OS-level handle to an open file.

    '''
    logger = logging.getLogger(__cononical_name__)
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    logger.debug('stem: %s ; directory: %s', stem, directory)

    if stem is None:
        try:
            stem = __cononical_name__
        except NameError:
            stem = __name__

    import tempfile
    if directory is not None and directory.lower() in 'directory':
        return tempfile.mkdtemp(prefix='%s-d.' % stem)
    return tempfile.mkstemp(prefix='%s.' % stem)

#==============================================================================
def get_timestamp(time_format=None):
    ''' Return date in specified format

    Args:
        time_format (str): Format string for timestamp. Compatible w/'date'.

    Returns:
        The formatted timestamp as a string.

    '''
    logger = logging.getLogger(__cononical_name__)
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    logger.debug('Passed format: %s', time_format)

    import time
    if time_format is None:
        try:
            time_format = __default_dsf__
        except NameError:
            time_format = "%Y%m%d-%H%M%S"
    return time.strftime(time_format.strip('+'))

#==============================================================================
def is_valid_ipv4(ipaddr):
    '''Checks if passed paramater is a valid IPv4 address'''
    parts = ipaddr.split('.')
    if len(parts) != 4:
        return False
    try:
        return all(0 <= int(p) < 256 for p in parts)
    except ValueError:
        return False

#==============================================================================
def set_value(filename, key, value):
    ''' Add or change a KEY to a VALUE in a FILE, creating FILE if necessary.

    Args:
        filename (str): File to create/modify
        key (str) :     Key to create/modify
        value (str):    Value to set key to

    Returns:
        Success/failure as a Boolean.

    '''
    logger = logging.getLogger(__cononical_name__)
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    logger.debug('Passed: file: %s, key: %s, value: %s', filename, key, value)

    raise NotImplementedError('TODO: implement set_value().')

#==============================================================================
def which(program):
    '''Test if a program exists in $PATH.

    Args:
        program (str): Name of program to find.

    Returns:
        String to use for program execution.

    Note:
        Originally found this here:
        http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
    '''
    logger = logging.getLogger(__cononical_name__)
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    logger.debug('Looking for command: %s', program)

    def _is_exe(fpath):
        ''' Private test for executeable '''
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, _ = os.path.split(program)
    if fpath:
        if _is_exe(program):
            logger.debug('Found %s here.', program)
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if _is_exe(exe_file):
                logger.debug('Found %s here: %s', program, exe_file)
                return exe_file

    logger.debug('Could not find %s.', program)
    return None


#==============================================================================
#-- Postscript v2.0.0
#==============================================================================
def main(options):
    ''' This is where the action takes place
    '''
    logger = logging.getLogger(options.mvars['name'])
    logger.debug('Starting main()')
    #-- TODO: Do something more interesting here...{#
    logger.debug('debug message')
    logger.info('info message')
    logger.warning('warn message')
    logger.error('error message')
    logger.critical('critical message')

    # print('%sAnsible Called: %s' % (colors._colors['cf_white'], options.ansible_called))
    # c = colors()
    # print('%sAnsible Called: %s%s' % (c.white, c.reset, options.ansible_called))
    # print('%sAnsible Called: %s' % (colors.white, options.ansible_called))
    # from pprint import pprint
    # print('%sAnsible Called: %s' % (colors._colors['cf_white'], options.ansible_called))
    # print (options._options)
    # print(timestamp())
    # print('FILE')
    # tempfile = get_temp()
    # print(tempfile)
    # os.remove(tempfile[1])
    # print('DIR')
    # tempdir = get_temp('dir')
    # print(tempdir)
    # os.rmdir(tempdir)
    # print('THING')
    # tempthing = get_temp('dat')
    # print(tempthing)
    # os.remove(tempthing[1])
    # print(__logger_file_set__)
    # raise OSError('Testing 1 2 3')
    # set_value('file', 'key', 'value')
    #}


#==============================================================================
if __name__ == '__main__':
    #-- Parse configs/envs/options and set up logging
    OPTS = Initilize(args=sys.argv[1:], mvars=METAVARS)
    # logger = logging.getLogger(OPTS.mvars['name'])
    if OPTS.mvars['flags']['require_root'] and os.getegid() != 0:
        OPTS.logger.error('Must be run as root.')
        sys.exit(77)

    #-- NOTE: "except Exception as variable:" syntax was added in 2.6, previously
    #         one would use "except Exception, variable:", but that is not
    #         compatible with 3.x. In order to be compatible with 2.5 (for RHEL 5)
    #         and forward, we use "execpt Exception:", then on the first line of
    #         the exception use "_, error, _ = sys.exc_info()". HOWEVER, pylint
    #         will no longer be able to warn on object members...
    #         type, value, traceback = sys.exc_info()
    try:
        main(OPTS)
    except SystemExit as error: # Catches sys.exit()
        #_, error, _ = sys.exc_info()
        OPTS.logger.debug('Caught SystemExit')
        OPTS.logger.warning('%s: [SystemExit] %s', OPTS.mvars['basename'], error)
    except KeyboardInterrupt: # Catches Ctrl-C
        OPTS.logger.debug('Caught Ctrl-C')
        EXIT_STATUS = 130
    except (OSError, IOError) as error:
        #_, error, _ = sys.exc_info()
        OPTS.logger.debug('Caught OSError')
        if error.errno is None:
            OPTS.logger.critical('%s: [OSError]: %s', OPTS.mvars['basename'], error)
            EXIT_STATUS = 10
        elif error.errno == 2:                #: No such file/directory
            OPTS.logger.critical('%s: [OSError] %s: %s', OPTS.mvars['basename'],
                                 error, error.filename
                                )
            EXIT_STATUS = os.EX_UNAVAILABLE
        elif error.errno == 13:                #: Permission Denied
            OPTS.logger.critical('%s: [OSError] %s: %s', OPTS.mvars['basename'],
                                 error, error.filename
                                )
            EXIT_STATUS = os.EX_NOPERM
        else:
            OPTS.logger.critical('%s: [OSError] %s', OPTS.mvars['basename'], error)
            EXIT_STATUS = error.errno
    except Exception as error:                   #: pylint: disable=broad-except
        #_, error, _ = sys.exc_info()
        OPTS.logger.debug('Caught Exception: %s', sys.exc_info())
        OPTS.logger.critical('%s: %s', OPTS.mvars['basename'], error)
        EXIT_STATUS = 10
    else:
        OPTS.logger.debug('main() exited cleanly.')
        if EXIT_STATUS is None:
            EXIT_STATUS = os.EX_OK
    #-- NOTE: "try..except..finally" does not work pre 2.5
    finally:
        OPTS.logger.debug('Mandatory clean-up.')
        if EXIT_STATUS is None:
            OPTS.logger.debug('EXIT_STATUS is still None.')
            EXIT_STATUS = 20
        if OPTS.debug:
            print('\n------ end ------\n')
        logging.shutdown()
        sys.exit(EXIT_STATUS)
    #-- NOTE: more exit codes here:
    #--   https://docs.python.org/2/library/os.html#process-management
